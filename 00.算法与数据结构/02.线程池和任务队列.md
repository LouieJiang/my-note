## 线程池和任务队列

#### 一、基础知识

- 列是连续的存储区，可以存储一系列的元素。
- 是FIFO（先入先出，FirstIn-First-Out）结构。 
- 队列通常具有头尾指针（左闭右开区间），头指针指向第一个元素，尾指 针指向最后一个元素的下一位。 
- 队列支持（从队尾）入队（enqueue）、（从队首）出队（dequeue）操 作。 循环队列可以通过取模操作更充分地利用空间。	
- 队列的基础知识

###### 二、队列的典型应用场景

- CPU的超线程技术
- 线程池的任务队列		

三、经典面试题

[86. 分隔链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/partition-list/submissions/)

```js
var partition = function(head, x) {
    if(!head) return null
    const hs = new ListNode();
    const hb = new ListNode();
    let p1 = hs;
    let p2 = hb;
    let p = head;
    let q = null;
    while(p){
        q = p.next;
        p.next = null;
        if(p.val < x){           
            [p1.next, p1] = [p, p];
        }else{
            [p2.next, p2] = [p, p];
        }
        p = q
    }
    p1.next = hb.next
    return hs.next
};
```

[138. 复制带随机指针的链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/copy-list-with-random-pointer/)

```js
var copyRandomList = function(head) {
    if(!head) return null
    let p = head;
    let q = null;
    while(p){
         q = new Node(p.val);
         q.random = p.random;
         q.next = p.next;
         p.next = q;
         p = q.next; 
    }
    p = head.next;
    while(p){
        p.random && (p.random = p.random.next);
        (p = p.next) && (p = p.next);
    }
    p = q = head.next;
    while(q.next){
        head.next = head.next.next;
        q.next = q.next.next;
        head = head.next;
        q = q.next;
    }
    head.next = null;
    return p;
};
```

[622. 设计循环队列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/design-circular-queue/submissions/)

```js
/**
 * @param {number} k
 */
var MyCircularQueue = function(k) {
    this.arr = new Array(k) ;
    this.head = 0;
    this.tail = 0;
    this.cnt = 0;
};

/** 
 * @param {number} value
 * @return {boolean}
 */
MyCircularQueue.prototype.enQueue = function(value) {
    if(this.isFull()) return false;
    this.arr[this.tail++] = value;
    this.tail = this.tail % this.arr.length;
    this.cnt++;
    return true;
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.deQueue = function() {
    if(this.isEmpty()) return false;
    this.head = (this.head + 1) % this.arr.length;
    this.cnt--;
    return true;
};

/**
 * @return {number}
 */
MyCircularQueue.prototype.Front = function() {
    if(this.isEmpty()) return -1
    return this.arr[this.head]
};

/**
 * @return {number}
 */
MyCircularQueue.prototype.Rear = function() {
    if(this.isEmpty()) return -1;
    return this.arr[(this.tail -1 + this.arr.length) % this.arr.length]
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isEmpty = function() {
    return !this.cnt
};

/**
 * @return {boolean}
 */
MyCircularQueue.prototype.isFull = function() {
    return this.cnt === this.arr.length;
};

```

[641. 设计循环双端队列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/design-circular-deque/submissions/)

```js
/**
 * Initialize your data structure here. Set the size of the deque to be k.
 * @param {number} k
 */
var MyCircularDeque = function(k) {
    this.arr = new Array(k);
    this.head = 0;
    this.tail = 0;
    this.cnt = 0;
};

/**
 * Adds an item at the front of Deque. Return true if the operation is successful. 
 * @param {number} value
 * @return {boolean}
 */
MyCircularDeque.prototype.insertFront = function(value) {
    if(this.isFull()) return false;
    this.head = (this.head - 1 + this.arr.length) % this.arr.length
    this.arr[this.head] = value;
    // console.log('arr', this.arr);
    // console.log('head', this.head);
    // console.log('tail', this.tail);
    this.cnt++ ;
    return true; 
};

/**
 * Adds an item at the rear of Deque. Return true if the operation is successful. 
 * @param {number} value
 * @return {boolean}
 */
MyCircularDeque.prototype.insertLast = function(value) {
    if(this.isFull()) return false;
    this.arr[this.tail++ ] = value;
    this.tail === this.arr.length && (this.tail = 0);
    this.cnt++;
    return true;
};

/**
 * Deletes an item from the front of Deque. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularDeque.prototype.deleteFront = function() {
    if(this.isEmpty()) return false;
    this.head = (this.head + 1) % this.arr.length;
    this.cnt--;
    return true;
};

/**
 * Deletes an item from the rear of Deque. Return true if the operation is successful.
 * @return {boolean}
 */
MyCircularDeque.prototype.deleteLast = function() {
    if(this.isEmpty()) return false;
    this.tail = (this.tail - 1 + this.arr.length) % this.arr.length;
    // console.log('tail2', this.tail);
    this.cnt--;
    return true;
};

/**
 * Get the front item from the deque.
 * @return {number}
 */
MyCircularDeque.prototype.getFront = function() {
    if(this.isEmpty()) return -1;
    return this.arr[this.head] 
};

/**
 * Get the last item from the deque.
 * @return {number}
 */
MyCircularDeque.prototype.getRear = function() {
    if(this.isEmpty()) return -1;
    return this.arr[(this.tail - 1 + this.arr.length) % this.arr.length]
};

/**
 * Checks whether the circular deque is empty or not.
 * @return {boolean}
 */
MyCircularDeque.prototype.isEmpty = function() {
    return !this.cnt
};

/**
 * Checks whether the circular deque is full or not.
 * @return {boolean}
 */
MyCircularDeque.prototype.isFull = function() {
    return this.cnt === this.arr.length;
};
```

[1670. 设计前中后队列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/design-front-middle-back-queue/)

```js
```

